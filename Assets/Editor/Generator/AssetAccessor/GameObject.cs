#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;

public static partial class AssetAccessorGenerator
{
  public static class GameObjectAccessor
  {
    public static void Generate(string outputDir)
    {
      if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
      {
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Creating directory: {outputDir}");
        _ = Directory.CreateDirectory(outputDir);
      }

      GenerateGameObjectFiles(outputDir);

      AssetDatabase.Refresh();
    }

    private static void GenerateGameObjectFiles(string outputDir)
    {
      var scenes = EditorBuildSettings.scenes
        .Where(s => s.enabled)
        .ToArray();

      if (scenes.Length == 0)
      {
        Console.WriteLine("[AssetAccessorGenerator.GameObjectAccessor] No scenes in build settings.");
        return;
      }

      foreach (var scene in scenes)
      {
        var sceneName = Path.GetFileNameWithoutExtension(scene.path);
        var sceneEnumName = MakeSafeName(sceneName);
        var gameObjects = ParseSceneGameObjects(scene.path);

        if (gameObjects.Count == 0)
        {
          continue;
        }

        var sb = new StringBuilder();

        _ = sb.AppendLine("// <auto-generated />");
        _ = sb.AppendLine($"// This file is generated by AssetAccessorGenerator.GameObjectAccessor for scene: {sceneName}. Do not edit manually.");
        _ = sb.AppendLine("using UnityEngine;");
        _ = sb.AppendLine();
        _ = sb.AppendLine("public static partial class AssetAccessor");
        _ = sb.AppendLine("{");
        _ = sb.AppendLine("  public static partial class Scene");
        _ = sb.AppendLine("  {");
        _ = sb.AppendLine($"    public static partial class {sceneEnumName}");
        _ = sb.AppendLine("    {");
        _ = sb.AppendLine("      public static partial class GameObject");
        _ = sb.AppendLine("      {");

        // Generate root GameObjects
        var rootGameObjects = gameObjects.Where(go => string.IsNullOrEmpty(go.ParentId)).ToList();
        var usedNames = new HashSet<string>();
        foreach (var go in rootGameObjects)
        {
          GenerateGameObjectClass(sb, go, gameObjects, 8, usedNames);
        }

        _ = sb.AppendLine("      }");
        _ = sb.AppendLine("    }");
        _ = sb.AppendLine("  }");
        _ = sb.AppendLine("}");

        var outputPath = Path.Combine(outputDir, $"{sceneEnumName}.cs");
        File.WriteAllText(outputPath, sb.ToString(), new UTF8Encoding(false));
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Generated: {outputPath}");
      }
    }

    private static void GenerateGameObjectClass(StringBuilder sb, GameObjectInfo go, List<GameObjectInfo> allGameObjects, int indent, HashSet<string> usedNames)
    {
      var indentStr = new string(' ', indent);
      var baseName = MakeSafeName(go.Name);
      var className = baseName;

      // Handle duplicate names by appending numbers
      var counter = 1;
      while (usedNames.Contains(className))
      {
        className = $"{baseName}{counter}";
        counter++;
      }

      _ = usedNames.Add(className);

      _ = sb.AppendLine($"{indentStr}public static class {className}");
      _ = sb.AppendLine($"{indentStr}{{");

      // Generate GetGameObject method
      _ = sb.AppendLine($"{indentStr}  public static UnityEngine.GameObject Get()");
      _ = sb.AppendLine($"{indentStr}  {{");
      _ = sb.AppendLine($"{indentStr}    return Scene.GameObjectCacheController.GetGameObject(\"{go.Name}\")");
      _ = sb.AppendLine($"{indentStr}      ?? throw new System.Exception($\"[AssetAccessor.GameObject] GameObject '{go.Name}' not found or scene not loaded\");");
      _ = sb.AppendLine($"{indentStr}  }}");

      // Generate type-safe Component accessor class
      if (go.Components.Count > 0)
      {
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static class Component");
        _ = sb.AppendLine($"{indentStr}  {{");

        foreach (var component in go.Components)
        {
          _ = sb.AppendLine($"{indentStr}    public static class {component.SafeName}");
          _ = sb.AppendLine($"{indentStr}    {{");
          _ = sb.AppendLine($"{indentStr}      public static {component.TypeFullName} Get()");
          _ = sb.AppendLine($"{indentStr}      {{");
          _ = sb.AppendLine($"{indentStr}        var go = {className}.Get();");
          _ = sb.AppendLine($"{indentStr}        var component = go.GetComponent<{component.TypeFullName}>();");
          _ = sb.AppendLine($"{indentStr}        if (component == null)");
          _ = sb.AppendLine($"{indentStr}        {{");
          _ = sb.AppendLine($"{indentStr}          throw new System.Exception($\"[AssetAccessor.GameObject] Component {component.TypeFullName} not found on GameObject '{go.Name}'\");");
          _ = sb.AppendLine($"{indentStr}        }}");
          _ = sb.AppendLine($"{indentStr}        return component;");
          _ = sb.AppendLine($"{indentStr}      }}");
          _ = sb.AppendLine($"{indentStr}    }}");
        }

        _ = sb.AppendLine($"{indentStr}  }}");
      }

      // Generate child GameObjects as nested classes
      var children = allGameObjects.Where(child => child.ParentId == go.Id).ToList();
      if (children.Count > 0)
      {
        _ = sb.AppendLine();

        // Reserve parent class name to prevent child classes from having the same name
        var childUsedNames = new HashSet<string> { className };

        foreach (var child in children)
        {
          GenerateGameObjectClass(sb, child, allGameObjects, indent + 2, childUsedNames);
        }
      }

      _ = sb.AppendLine($"{indentStr}}}");
    }

    private static List<GameObjectInfo> ParseSceneGameObjects(string scenePath)
    {
      var gameObjects = new List<GameObjectInfo>();

      if (!File.Exists(scenePath))
      {
        return gameObjects;
      }

      var content = File.ReadAllText(scenePath);

      // Parse PrefabInstances to extract GameObject names, parent transforms, and GUIDs
      var prefabInstancePattern = new Regex(
        @"--- !u!1001 &(\d+)\s+PrefabInstance:.*?m_TransformParent: \{fileID: (\d+)\}.*?propertyPath: m_Name\s+value: (.+?)\s+.*?guid: ([0-9a-f]+),",
        RegexOptions.Singleline
      );
      var prefabMatches = prefabInstancePattern.Matches(content);
      var prefabInstances = new Dictionary<string, (string parentTransformId, string name, string guid)>();

      foreach (Match match in prefabMatches)
      {
        var prefabId = match.Groups[1].Value;
        var parentTransformId = match.Groups[2].Value;
        var name = match.Groups[3].Value.Trim();
        var guid = match.Groups[4].Value.Trim();
        prefabInstances[prefabId] = (parentTransformId, name, guid);
      }

      // Parse stripped transforms from PrefabInstances
      // Pattern: --- !u!224 &<transformId> stripped\nRectTransform:...\n  m_PrefabInstance: {fileID: <prefabId>}
      var strippedTransformPattern = new Regex(
        @"--- !u!(?:224|4) &(\d+) stripped\s+(?:RectTransform|Transform):.*?m_PrefabInstance: \{fileID: (\d+)\}",
        RegexOptions.Singleline
      );
      var strippedMatches = strippedTransformPattern.Matches(content);
      var prefabTransformToPrefabId = new Dictionary<string, string>();

      foreach (Match match in strippedMatches)
      {
        var transformId = match.Groups[1].Value;
        var prefabId = match.Groups[2].Value;
        if (prefabInstances.ContainsKey(prefabId))
        {
          prefabTransformToPrefabId[transformId] = prefabId;
        }
      }

      // Parse stripped GameObjects from PrefabInstances
      // Pattern: --- !u!1 &<gameObjectId> stripped\nGameObject:...\n  m_PrefabInstance: {fileID: <prefabId>}
      var strippedGameObjectPattern = new Regex(
        @"--- !u!1 &(\d+) stripped\s+GameObject:.*?m_PrefabInstance: \{fileID: (\d+)\}",
        RegexOptions.Singleline
      );
      var strippedGameObjectMatches = strippedGameObjectPattern.Matches(content);
      var strippedGameObjectToPrefabId = new Dictionary<string, string>();

      foreach (Match match in strippedGameObjectMatches)
      {
        var gameObjectId = match.Groups[1].Value;
        var prefabId = match.Groups[2].Value;
        if (prefabInstances.ContainsKey(prefabId))
        {
          strippedGameObjectToPrefabId[gameObjectId] = prefabId;
        }
      }

      // Parse GameObjects from YAML
      // Pattern: --- !u!1 &<id>\nGameObject:\n...\n  m_Name: <name>
      var gameObjectPattern = new Regex(@"--- !u!1 &(\d+)\s+GameObject:.*?m_Name:\s*(.+?)$", RegexOptions.Singleline | RegexOptions.Multiline);
      var matches = gameObjectPattern.Matches(content);

      foreach (Match match in matches)
      {
        var id = match.Groups[1].Value;
        var name = match.Groups[2].Value.Trim();

        if (string.IsNullOrEmpty(name))
        {
          continue; // Skip empty names
        }

        gameObjects.Add(new GameObjectInfo
        {
          Id = id,
          Name = name,
          ParentId = null,
          IsPrefabInstance = false,
          PrefabGuid = null
        });
      }

      // Add PrefabInstance GameObjects with virtual IDs
      foreach (var kvp in prefabInstances)
      {
        var prefabId = kvp.Key;
        var (parentTransformId, name, guid) = kvp.Value;

        gameObjects.Add(new GameObjectInfo
        {
          Id = $"prefab_{prefabId}",
          Name = name,
          ParentId = null, // Will be resolved later
          IsPrefabInstance = true,
          PrefabGuid = guid,
          PrefabParentTransformId = parentTransformId
        });
      }

      // Build mapping: Transform/RectTransform ID -> GameObject ID
      var transformToGameObject = new Dictionary<string, string>();

      // Pattern matches Transform or RectTransform blocks
      // Match from block start to next block or end of file
      var transformBlockPattern = new Regex(@"--- !u!(?:224|4) &(\d+)\s+(?:RectTransform|Transform):.*?(?=^--- |\z)", RegexOptions.Singleline | RegexOptions.Multiline);
      var transformMatches = transformBlockPattern.Matches(content);

      // Convert to array for multiple iterations
      var transformBlocks = transformMatches.Cast<Match>().ToArray();

      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (gameObjectMatch.Success)
        {
          var gameObjectId = gameObjectMatch.Groups[1].Value;
          transformToGameObject[transformId] = gameObjectId;
        }
      }

      // Parse parent-child relationships
      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (!gameObjectMatch.Success) continue;
        var gameObjectId = gameObjectMatch.Groups[1].Value;

        // Extract m_Father from this block
        var fatherMatch = Regex.Match(blockContent, @"m_Father:\s*\{fileID:\s*(\d+)\}");
        if (!fatherMatch.Success) continue;
        var parentTransformId = fatherMatch.Groups[1].Value;

        // parentId "0" means no parent (root GameObject)
        if (parentTransformId != "0" && transformToGameObject.TryGetValue(parentTransformId, out var parentGameObjectId))
        {
          var go = gameObjects.FirstOrDefault(g => g.Id == gameObjectId);
          if (go != null)
          {
            go.ParentId = parentGameObjectId;
          }
        }
      }

      // Resolve PrefabInstance parent relationships
      foreach (var go in gameObjects.Where(g => g.IsPrefabInstance))
      {
        var parentTransformId = go.PrefabParentTransformId;
        if (!string.IsNullOrEmpty(parentTransformId) && parentTransformId != "0")
        {
          if (transformToGameObject.TryGetValue(parentTransformId, out var parentGameObjectId))
          {
            go.ParentId = parentGameObjectId;
          }
        }
      }

      // Parse components for each GameObject
      ParseComponentsForGameObjects(content, gameObjects, strippedGameObjectToPrefabId);

      // Load components from prefab files for PrefabInstances
      LoadPrefabComponents(gameObjects, Path.GetDirectoryName(scenePath));

      return gameObjects;
    }

    private static void ParseComponentsForGameObjects(string content, List<GameObjectInfo> gameObjects, Dictionary<string, string> strippedGameObjectToPrefabId)
    {
      // Create a dictionary for quick lookup
      var gameObjectDict = gameObjects.ToDictionary(go => go.Id);

      // Parse MonoBehaviour components (UI components like Image, Button, Text, etc.)
      // Match both regular and stripped MonoBehaviour components
      var monoBehaviourPattern = new Regex(
        @"--- !u!114 &\d+(?:\s+stripped)?\s+MonoBehaviour:.*?m_GameObject:\s*\{fileID:\s*(\d+)\}.*?m_EditorClassIdentifier:\s*(.+?)$",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var monoBehaviourMatches = monoBehaviourPattern.Matches(content);

      foreach (Match match in monoBehaviourMatches)
      {
        var gameObjectId = match.Groups[1].Value;
        var editorClassIdentifier = match.Groups[2].Value.Trim();

        // Try to find the GameObject directly, or map from stripped GameObject ID to PrefabInstance virtual ID
        if (!gameObjectDict.TryGetValue(gameObjectId, out GameObjectInfo go))
        {
          // This might be a stripped GameObject from a PrefabInstance, try to map it to the virtual GameObject ID
          if (strippedGameObjectToPrefabId.TryGetValue(gameObjectId, out var prefabId))
          {
            var virtualId = $"prefab_{prefabId}";
            _ = gameObjectDict.TryGetValue(virtualId, out go);
          }
        }

        if (go != null && !string.IsNullOrEmpty(editorClassIdentifier))
        {
          var componentType = ParseComponentType(editorClassIdentifier);
          if (!string.IsNullOrEmpty(componentType) && IsUnityOrKnownComponent(componentType))
          {
            var safeName = MakeSafeName(componentType.Split('.').Last());
            go.Components.Add(new ComponentInfo
            {
              TypeFullName = componentType,
              SafeName = safeName
            });
          }
        }
      }

      // Parse other common component types
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!223", "UnityEngine.Canvas", "Canvas");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!222", "UnityEngine.CanvasRenderer", "CanvasRenderer");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!224", "UnityEngine.RectTransform", "RectTransform");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!4", "UnityEngine.Transform", "Transform");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!20", "UnityEngine.Camera", "Camera");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!81", "UnityEngine.AudioListener", "AudioListener");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!108", "UnityEngine.Light", "Light");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!114", "UnityEngine.EventSystems.EventSystem", "EventSystem");
    }

    private static void ParseStandardComponents(string content, Dictionary<string, GameObjectInfo> gameObjectDict, Dictionary<string, string> strippedGameObjectToPrefabId, string classId, string componentType, string componentName)
    {
      var pattern = new Regex(
        $@"--- {Regex.Escape(classId)} &\d+\s+{Regex.Escape(componentName)}:.*?m_GameObject:\s*\{{fileID:\s*(\d+)\}}",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var matches = pattern.Matches(content);

      foreach (Match match in matches)
      {
        var gameObjectId = match.Groups[1].Value;

        // Try to find the GameObject directly, or map from stripped GameObject ID to PrefabInstance virtual ID
        if (!gameObjectDict.TryGetValue(gameObjectId, out GameObjectInfo go))
        {
          // This might be a stripped GameObject from a PrefabInstance, try to map it to the virtual GameObject ID
          if (strippedGameObjectToPrefabId.TryGetValue(gameObjectId, out var prefabId))
          {
            var virtualId = $"prefab_{prefabId}";
            _ = gameObjectDict.TryGetValue(virtualId, out go);
          }
        }

        if (go != null)
        {
          var safeName = MakeSafeName(componentType.Split('.').Last());
          // Avoid duplicates
          if (!go.Components.Any(c => c.TypeFullName == componentType))
          {
            go.Components.Add(new ComponentInfo
            {
              TypeFullName = componentType,
              SafeName = safeName
            });
          }
        }
      }
    }

    private static string ParseComponentType(string editorClassIdentifier)
    {
      // editorClassIdentifier format examples:
      // "UnityEngine.UI::UnityEngine.UI.Image"
      // "UnityEngine.EventSystems::UnityEngine.EventSystems.EventSystem"
      // "::CustomScript"

      if (string.IsNullOrEmpty(editorClassIdentifier))
      {
        return null;
      }

      var parts = editorClassIdentifier.Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);
      if (parts.Length == 2)
      {
        return parts[1].Trim();
      }
      else if (parts.Length == 1)
      {
        return parts[0].Trim();
      }

      return null;
    }

    private static bool IsUnityOrKnownComponent(string componentType)
    {
      if (string.IsNullOrEmpty(componentType))
      {
        return false;
      }

      // Include only Unity engine components and known third-party packages
      // Exclude custom user scripts
      return componentType.StartsWith("UnityEngine.") ||
            componentType.StartsWith("UnityEditor.") ||
            componentType.StartsWith("Unity.") ||
            componentType.StartsWith("TMPro.") || // TextMeshPro
            componentType.StartsWith("Cinemachine.") || // Cinemachine
            componentType.StartsWith("UnityEngine.InputSystem."); // Input System
    }

    private static void LoadPrefabComponents(List<GameObjectInfo> gameObjects, string sceneDir)
    {
      // Get the Assets directory path
      var assetsPath = Path.GetFullPath(Path.Combine(sceneDir, "..", ".."));

      foreach (var go in gameObjects.Where(g => g.IsPrefabInstance && !string.IsNullOrEmpty(g.PrefabGuid)))
      {
        // Find prefab file by GUID
        var prefabPath = FindAssetPathByGuid(go.PrefabGuid, assetsPath);
        if (string.IsNullOrEmpty(prefabPath) || !File.Exists(prefabPath))
        {
          continue;
        }

        // Parse prefab file to extract components
        var prefabContent = File.ReadAllText(prefabPath);
        var prefabComponents = ParsePrefabComponents(prefabContent);

        // Add components that aren't already in the list (from scene overrides)
        foreach (var component in prefabComponents)
        {
          if (!go.Components.Any(c => c.TypeFullName == component.TypeFullName))
          {
            go.Components.Add(component);
          }
        }
      }
    }

    private static string FindAssetPathByGuid(string guid, string assetsPath)
    {
      // Search for .meta files containing the GUID
      var metaFiles = Directory.GetFiles(assetsPath, "*.meta", SearchOption.AllDirectories);

      foreach (var metaFile in metaFiles)
      {
        var metaContent = File.ReadAllText(metaFile);
        if (metaContent.Contains($"guid: {guid}"))
        {
          // Return the actual file path (remove .meta extension)
          var assetPath = metaFile[..^5];
          if (File.Exists(assetPath))
          {
            return assetPath;
          }
        }
      }

      return null;
    }

    private static List<ComponentInfo> ParsePrefabComponents(string prefabContent)
    {
      var components = new List<ComponentInfo>();
      var addedTypes = new HashSet<string>();

      // Find the root GameObject ID in the prefab
      var rootGameObjectMatch = Regex.Match(prefabContent, @"--- !u!1 &(\d+)\s+GameObject:");
      if (!rootGameObjectMatch.Success)
      {
        return components;
      }

      var rootGameObjectId = rootGameObjectMatch.Groups[1].Value;

      // Parse MonoBehaviour components
      var monoBehaviourPattern = new Regex(
        @"--- !u!114 &\d+(?:\s+stripped)?\s+MonoBehaviour:.*?m_GameObject:\s*\{fileID:\s*(\d+)\}.*?m_EditorClassIdentifier:\s*(.+?)$",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var monoBehaviourMatches = monoBehaviourPattern.Matches(prefabContent);

      foreach (Match match in monoBehaviourMatches)
      {
        var gameObjectId = match.Groups[1].Value;
        if (gameObjectId != rootGameObjectId) continue;

        var editorClassIdentifier = match.Groups[2].Value.Trim();
        var componentType = ParseComponentType(editorClassIdentifier);

        if (!string.IsNullOrEmpty(componentType) && IsUnityOrKnownComponent(componentType) && !addedTypes.Contains(componentType))
        {
          var safeName = MakeSafeName(componentType.Split('.').Last());
          components.Add(new ComponentInfo
          {
            TypeFullName = componentType,
            SafeName = safeName
          });
          _ = addedTypes.Add(componentType);
        }
      }

      // Parse standard components
      ParsePrefabStandardComponent(prefabContent, rootGameObjectId, "!u!223", "UnityEngine.Canvas", components, addedTypes);
      ParsePrefabStandardComponent(prefabContent, rootGameObjectId, "!u!222", "UnityEngine.CanvasRenderer", components, addedTypes);
      ParsePrefabStandardComponent(prefabContent, rootGameObjectId, "!u!224", "UnityEngine.RectTransform", components, addedTypes);
      ParsePrefabStandardComponent(prefabContent, rootGameObjectId, "!u!4", "UnityEngine.Transform", components, addedTypes);
      ParsePrefabStandardComponent(prefabContent, rootGameObjectId, "!u!20", "UnityEngine.Camera", components, addedTypes);
      ParsePrefabStandardComponent(prefabContent, rootGameObjectId, "!u!81", "UnityEngine.AudioListener", components, addedTypes);
      ParsePrefabStandardComponent(prefabContent, rootGameObjectId, "!u!108", "UnityEngine.Light", components, addedTypes);

      return components;
    }

    private static void ParsePrefabStandardComponent(string content, string gameObjectId, string classId, string componentType, List<ComponentInfo> components, HashSet<string> addedTypes)
    {
      var componentName = componentType.Split('.').Last();
      var pattern = new Regex(
        $@"--- {Regex.Escape(classId)} &\d+\s+{Regex.Escape(componentName)}:.*?m_GameObject:\s*\{{fileID:\s*(\d+)\}}",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var matches = pattern.Matches(content);

      foreach (Match match in matches)
      {
        var goId = match.Groups[1].Value;
        if (goId == gameObjectId && !addedTypes.Contains(componentType))
        {
          var safeName = MakeSafeName(componentName);
          components.Add(new ComponentInfo
          {
            TypeFullName = componentType,
            SafeName = safeName
          });
          _ = addedTypes.Add(componentType);
          break;
        }
      }
    }

    private static string MakeSafeName(string name)
    {
      if (string.IsNullOrEmpty(name)) return "_";

      var sb = new StringBuilder(name.Length);
      bool upperNext = true;

      foreach (var ch in name)
      {
        if (char.IsLetterOrDigit(ch))
        {
          _ = sb.Append(upperNext ? char.ToUpperInvariant(ch) : ch);
          upperNext = false;
        }
        else
        {
          upperNext = true;
        }
      }

      if (sb.Length == 0) _ = sb.Append("_");
      if (char.IsDigit(sb[0])) _ = sb.Insert(0, '_');

      var result = sb.ToString();

      // Avoid reserved/problematic names that would conflict with enclosing types or Unity types
      if (result == "GameObject")
      {
        result = $"{result}_";
      }

      return result;
    }

    private class GameObjectInfo
    {
      public string Id { get; set; }
      public string Name { get; set; }
      public string ParentId { get; set; }
      public List<ComponentInfo> Components { get; set; } = new List<ComponentInfo>();
      public bool IsPrefabInstance { get; set; }
      public string PrefabGuid { get; set; }
      public string PrefabParentTransformId { get; set; }
    }

    private class ComponentInfo
    {
      public string TypeFullName { get; set; }
      public string SafeName { get; set; }
    }
  }
}
#endif
