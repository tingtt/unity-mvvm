#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;

public static partial class AssetAccessorGenerator
{
  public static class GameObjectAccessor
  {
    public static void Generate(string outputDir)
    {
      if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
      {
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Creating directory: {outputDir}");
        _ = Directory.CreateDirectory(outputDir);
      }

      GenerateGameObjectFiles(outputDir);

      AssetDatabase.Refresh();
    }

    private static void GenerateGameObjectFiles(string outputDir)
    {
      var scenes = EditorBuildSettings.scenes
        .Where(s => s.enabled)
        .ToArray();

      if (scenes.Length == 0)
      {
        Console.WriteLine("[AssetAccessorGenerator.GameObjectAccessor] No scenes in build settings.");
        return;
      }

      foreach (var scene in scenes)
      {
        var sceneName = Path.GetFileNameWithoutExtension(scene.path);
        var sceneEnumName = MakeSafeName(sceneName);
        var gameObjects = ParseSceneGameObjects(scene.path);

        if (gameObjects.Count == 0)
        {
          continue;
        }

        var sb = new StringBuilder();

        _ = sb.AppendLine("// <auto-generated />");
        _ = sb.AppendLine($"// This file is generated by AssetAccessorGenerator.GameObjectAccessor for scene: {sceneName}. Do not edit manually.");
        _ = sb.AppendLine("using UnityEngine;");
        _ = sb.AppendLine();
        _ = sb.AppendLine("public static partial class AssetAccessor");
        _ = sb.AppendLine("{");
        _ = sb.AppendLine("  public static partial class Scene");
        _ = sb.AppendLine("  {");
        _ = sb.AppendLine($"    public static partial class {sceneEnumName}");
        _ = sb.AppendLine("    {");
        _ = sb.AppendLine("      public static partial class GameObject");
        _ = sb.AppendLine("      {");

        // Generate root GameObjects
        var rootGameObjects = gameObjects.Where(go => string.IsNullOrEmpty(go.ParentId)).ToList();
        var usedNames = new HashSet<string>();
        foreach (var go in rootGameObjects)
        {
          GenerateGameObjectClass(sb, go, gameObjects, 8, usedNames);
        }

        _ = sb.AppendLine("      }");
        _ = sb.AppendLine("    }");
        _ = sb.AppendLine("  }");
        _ = sb.AppendLine("}");

        var outputPath = Path.Combine(outputDir, $"{sceneEnumName}.cs");
        File.WriteAllText(outputPath, sb.ToString(), new UTF8Encoding(false));
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Generated: {outputPath}");
      }
    }

    private static void GenerateGameObjectClass(StringBuilder sb, GameObjectInfo go, List<GameObjectInfo> allGameObjects, int indent, HashSet<string> usedNames)
    {
      var indentStr = new string(' ', indent);
      var baseName = MakeSafeName(go.Name);
      var className = baseName;

      // Handle duplicate names by appending numbers
      var counter = 1;
      while (usedNames.Contains(className))
      {
        className = $"{baseName}{counter}";
        counter++;
      }

      _ = usedNames.Add(className);

      _ = sb.AppendLine($"{indentStr}public static class {className}");
      _ = sb.AppendLine($"{indentStr}{{");

      // Generate GetGameObject method
      _ = sb.AppendLine($"{indentStr}  public static UnityEngine.GameObject Get()");
      _ = sb.AppendLine($"{indentStr}  {{");
      _ = sb.AppendLine($"{indentStr}    return Scene.GameObjectCacheController.GetGameObject(\"{go.Name}\")");
      _ = sb.AppendLine($"{indentStr}      ?? throw new System.Exception($\"[AssetAccessor.GameObject] GameObject '{go.Name}' not found or scene not loaded\");");
      _ = sb.AppendLine($"{indentStr}  }}");
      _ = sb.AppendLine();

      // Generate GetComponent method
      _ = sb.AppendLine($"{indentStr}  public static T GetComponent<T>() where T : Component");
      _ = sb.AppendLine($"{indentStr}  {{");
      _ = sb.AppendLine($"{indentStr}    var go = Get();");
      _ = sb.AppendLine($"{indentStr}    var component = go.GetComponent<T>();");
      _ = sb.AppendLine($"{indentStr}    if (component == null)");
      _ = sb.AppendLine($"{indentStr}    {{");
      _ = sb.AppendLine($"{indentStr}      throw new System.Exception($\"[AssetAccessor.GameObject] Component {{typeof(T).Name}} not found on GameObject '{go.Name}'\");");
      _ = sb.AppendLine($"{indentStr}    }}");
      _ = sb.AppendLine($"{indentStr}    return component;");
      _ = sb.AppendLine($"{indentStr}  }}");

      // Generate child GameObjects as nested classes
      var children = allGameObjects.Where(child => child.ParentId == go.Id).ToList();
      if (children.Count > 0)
      {
        _ = sb.AppendLine();

        // Reserve parent class name to prevent child classes from having the same name
        var childUsedNames = new HashSet<string> { className };

        foreach (var child in children)
        {
          GenerateGameObjectClass(sb, child, allGameObjects, indent + 2, childUsedNames);
        }
      }

      _ = sb.AppendLine($"{indentStr}}}");
    }

    private static List<GameObjectInfo> ParseSceneGameObjects(string scenePath)
    {
      var gameObjects = new List<GameObjectInfo>();

      if (!File.Exists(scenePath))
      {
        return gameObjects;
      }

      var content = File.ReadAllText(scenePath);

      // Parse GameObjects from YAML
      // Pattern: --- !u!1 &<id>\nGameObject:\n...\n  m_Name: <name>
      var gameObjectPattern = new Regex(@"--- !u!1 &(\d+)\s+GameObject:.*?m_Name:\s*(.+?)$", RegexOptions.Singleline | RegexOptions.Multiline);
      var matches = gameObjectPattern.Matches(content);

      foreach (Match match in matches)
      {
        var id = match.Groups[1].Value;
        var name = match.Groups[2].Value.Trim();

        if (string.IsNullOrEmpty(name))
        {
          continue; // Skip empty names
        }

        gameObjects.Add(new GameObjectInfo
        {
          Id = id,
          Name = name,
          ParentId = null
        });
      }

      // Build mapping: Transform/RectTransform ID -> GameObject ID
      var transformToGameObject = new Dictionary<string, string>();

      // Pattern matches Transform or RectTransform blocks
      // Match from block start to next block or end of file
      var transformBlockPattern = new Regex(@"--- !u!(?:224|4) &(\d+)\s+(?:RectTransform|Transform):.*?(?=^--- |\z)", RegexOptions.Singleline | RegexOptions.Multiline);
      var transformMatches = transformBlockPattern.Matches(content);

      // Convert to array for multiple iterations
      var transformBlocks = transformMatches.Cast<Match>().ToArray();

      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (gameObjectMatch.Success)
        {
          var gameObjectId = gameObjectMatch.Groups[1].Value;
          transformToGameObject[transformId] = gameObjectId;
        }
      }

      // Parse parent-child relationships
      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (!gameObjectMatch.Success) continue;
        var gameObjectId = gameObjectMatch.Groups[1].Value;

        // Extract m_Father from this block
        var fatherMatch = Regex.Match(blockContent, @"m_Father:\s*\{fileID:\s*(\d+)\}");
        if (!fatherMatch.Success) continue;
        var parentTransformId = fatherMatch.Groups[1].Value;

        // parentId "0" means no parent (root GameObject)
        if (parentTransformId != "0" && transformToGameObject.TryGetValue(parentTransformId, out var parentGameObjectId))
        {
          var go = gameObjects.FirstOrDefault(g => g.Id == gameObjectId);
          if (go != null)
          {
            go.ParentId = parentGameObjectId;
          }
        }
      }

      return gameObjects;
    }

    private static string MakeSafeName(string name)
    {
      if (string.IsNullOrEmpty(name)) return "_";

      var sb = new StringBuilder(name.Length);
      bool upperNext = true;

      foreach (var ch in name)
      {
        if (char.IsLetterOrDigit(ch))
        {
          _ = sb.Append(upperNext ? char.ToUpperInvariant(ch) : ch);
          upperNext = false;
        }
        else
        {
          upperNext = true;
        }
      }

      if (sb.Length == 0) _ = sb.Append("_");
      if (char.IsDigit(sb[0])) _ = sb.Insert(0, '_');

      var result = sb.ToString();

      // Avoid reserved/problematic names that would conflict with enclosing types or Unity types
      if (result == "GameObject")
      {
        result = $"{result}_";
      }

      return result;
    }

    private class GameObjectInfo
    {
      public string Id { get; set; }
      public string Name { get; set; }
      public string ParentId { get; set; }
    }
  }
}
#endif
