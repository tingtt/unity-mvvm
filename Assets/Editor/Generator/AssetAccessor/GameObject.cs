#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;

public static partial class AssetAccessorGenerator
{
  public static class GameObjectAccessor
  {
    public static void Generate(string outputDir)
    {
      if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
      {
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Creating directory: {outputDir}");
        _ = Directory.CreateDirectory(outputDir);
      }

      GenerateGameObjectFiles(outputDir);

      AssetDatabase.Refresh();
    }

    private static void GenerateGameObjectFiles(string outputDir)
    {
      var scenes = EditorBuildSettings.scenes
        .Where(s => s.enabled)
        .ToArray();

      if (scenes.Length == 0)
      {
        Console.WriteLine("[AssetAccessorGenerator.GameObjectAccessor] No scenes in build settings.");
        return;
      }

      foreach (var scene in scenes)
      {
        var sceneName = Path.GetFileNameWithoutExtension(scene.path);
        var sceneEnumName = MakeSafeName(sceneName);
        var gameObjects = ParseSceneGameObjects(scene.path);

        if (gameObjects.Count == 0)
        {
          continue;
        }

        var sb = new StringBuilder();

        _ = sb.AppendLine("// <auto-generated />");
        _ = sb.AppendLine($"// This file is generated by AssetAccessorGenerator.GameObjectAccessor for scene: {sceneName}. Do not edit manually.");
        _ = sb.AppendLine("using UnityEngine;");

        // Generate using aliases for custom scripts to avoid name conflicts
        var customScriptAliases = GenerateCustomScriptAliases(gameObjects);
        foreach (var alias in customScriptAliases)
        {
          _ = sb.AppendLine(alias);
        }

        _ = sb.AppendLine();
        _ = sb.AppendLine("public static partial class AssetAccessor");
        _ = sb.AppendLine("{");
        _ = sb.AppendLine("  public static partial class Scene");
        _ = sb.AppendLine("  {");
        _ = sb.AppendLine($"    public static partial class {sceneEnumName}");
        _ = sb.AppendLine("    {");
        _ = sb.AppendLine("      public static partial class GameObject");
        _ = sb.AppendLine("      {");

        // Generate root GameObjects
        var rootGameObjects = gameObjects.Where(go => string.IsNullOrEmpty(go.ParentId)).ToList();
        var usedNames = new HashSet<string>();
        foreach (var go in rootGameObjects)
        {
          GenerateGameObjectClass(sb, go, gameObjects, 8, usedNames);
        }

        _ = sb.AppendLine("      }");
        _ = sb.AppendLine("    }");
        _ = sb.AppendLine("  }");
        _ = sb.AppendLine("}");

        var outputPath = Path.Combine(outputDir, $"{sceneEnumName}.cs");
        File.WriteAllText(outputPath, sb.ToString(), new UTF8Encoding(false));
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Generated: {outputPath}");
      }
    }

    private static void GenerateGameObjectClass(StringBuilder sb, GameObjectInfo go, List<GameObjectInfo> allGameObjects, int indent, HashSet<string> usedNames)
    {
      var indentStr = new string(' ', indent);
      var baseName = MakeSafeName(go.Name);
      var className = baseName;

      // Handle duplicate names by appending numbers
      var counter = 1;
      while (usedNames.Contains(className))
      {
        className = $"{baseName}{counter}";
        counter++;
      }

      _ = usedNames.Add(className);

      _ = sb.AppendLine($"{indentStr}public static class {className}");
      _ = sb.AppendLine($"{indentStr}{{");

      // Generate GetGameObject method
      _ = sb.AppendLine($"{indentStr}  public static UnityEngine.GameObject Get()");
      _ = sb.AppendLine($"{indentStr}  {{");

      if (go.IsPrefabChild)
      {
        // Prefab child: find via parent's transform
        var parentGO = allGameObjects.FirstOrDefault(g => g.Id == go.ParentId);
        var parentClassName = parentGO != null ? MakeSafeName(parentGO.Name) : "Parent";
        _ = sb.AppendLine($"{indentStr}    var parent = {parentClassName}.Get();");
        _ = sb.AppendLine($"{indentStr}    var child = parent.transform.Find(\"{go.Name}\");");
        _ = sb.AppendLine($"{indentStr}    if (child == null)");
        _ = sb.AppendLine($"{indentStr}    {{");
        _ = sb.AppendLine($"{indentStr}      throw new System.Exception($\"[AssetAccessor.GameObject] Child GameObject '{go.Name}' not found under parent\");");
        _ = sb.AppendLine($"{indentStr}    }}");
        _ = sb.AppendLine($"{indentStr}    return child.gameObject;");
      }
      else
      {
        // Regular GameObject or PrefabInstance root: find via cache
        _ = sb.AppendLine($"{indentStr}    return Scene.GameObjectCacheController.GetGameObject(\"{go.Name}\")");
        _ = sb.AppendLine($"{indentStr}      ?? throw new System.Exception($\"[AssetAccessor.GameObject] GameObject '{go.Name}' not found or scene not loaded\");");
      }

      _ = sb.AppendLine($"{indentStr}  }}");

      // Generate direct accessors for custom script members
      var customScriptWithMembers = go.Components.FirstOrDefault(c => c.IsCustomScript && c.CustomScriptMembers.Count > 0);
      if (customScriptWithMembers != null)
      {
        foreach (var member in customScriptWithMembers.CustomScriptMembers)
        {
          _ = sb.AppendLine();
          if (member.Type is MemberType.Property or MemberType.Field)
          {
            // Generate getter
            _ = sb.AppendLine($"{indentStr}  public static {member.ReturnType} {member.Name}");
            _ = sb.AppendLine($"{indentStr}  {{");
            _ = sb.AppendLine($"{indentStr}    get {{ return Component.Script.Get{customScriptWithMembers.SafeName}().{member.Name}; }}");
            // Generate setter only if the property has one
            if (member.HasSetter)
            {
              _ = sb.AppendLine($"{indentStr}    set {{ Component.Script.Get{customScriptWithMembers.SafeName}().{member.Name} = value; }}");
            }

            _ = sb.AppendLine($"{indentStr}  }}");
          }
          else if (member.Type == MemberType.Method)
          {
            // Generate method wrapper
            var parameters = string.Join(", ", member.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var arguments = string.Join(", ", member.Parameters.Select(p => p.Name));
            _ = sb.AppendLine($"{indentStr}  public static {member.ReturnType} {member.Name}({parameters})");
            _ = sb.AppendLine($"{indentStr}  {{");
            var returnPrefix = member.ReturnType == "void" ? "" : "return ";
            _ = sb.AppendLine($"{indentStr}    {returnPrefix}Component.Script.Get{customScriptWithMembers.SafeName}().{member.Name}({arguments});");
            _ = sb.AppendLine($"{indentStr}  }}");
          }
        }
      }

      // Generate convenience methods for Button component if present
      var buttonComponent = go.Components.FirstOrDefault(c => c.TypeFullName == "UnityEngine.UI.Button");
      if (buttonComponent != null)
      {
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void AddOnClickListener(UnityEngine.Events.UnityAction action)");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.Button.Get().onClick.AddListener(action);");
        _ = sb.AppendLine($"{indentStr}  }}");
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void Activate()");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.Button.Get().interactable = true;");
        _ = sb.AppendLine($"{indentStr}  }}");
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void Deactivate()");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.Button.Get().interactable = false;");
        _ = sb.AppendLine($"{indentStr}  }}");
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void InvokeOnClick()");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.Button.Get().onClick.Invoke();");
        _ = sb.AppendLine($"{indentStr}  }}");
      }

      // Generate convenience methods for TMP_InputField component if present
      var tmpInputFieldComponent = go.Components.FirstOrDefault(c => c.TypeFullName == "TMPro.TMP_InputField");
      if (tmpInputFieldComponent != null)
      {
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void Activate()");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.{tmpInputFieldComponent.SafeName}.Get().ActivateInputField();");
        _ = sb.AppendLine($"{indentStr}  }}");
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void Deactivate()");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.{tmpInputFieldComponent.SafeName}.Get().DeactivateInputField();");
        _ = sb.AppendLine($"{indentStr}  }}");
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void SetText(string text)");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.{tmpInputFieldComponent.SafeName}.Get().textComponent.SetText(text);");
        _ = sb.AppendLine($"{indentStr}  }}");
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void AddOnSubmitListener(UnityEngine.Events.UnityAction<string> action)");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.{tmpInputFieldComponent.SafeName}.Get().onSubmit.AddListener(action);");
        _ = sb.AppendLine($"{indentStr}  }}");
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void AddOnValueChangedListener(UnityEngine.Events.UnityAction<string> action)");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.{tmpInputFieldComponent.SafeName}.Get().onValueChanged.AddListener(action);");
        _ = sb.AppendLine($"{indentStr}  }}");
      }

      // Generate convenience methods for TextMeshProUGUI component if present
      var textMeshProComponent = go.Components.FirstOrDefault(c => c.TypeFullName == "TMPro.TextMeshProUGUI");
      if (textMeshProComponent != null)
      {
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static void SetText(string text)");
        _ = sb.AppendLine($"{indentStr}  {{");
        _ = sb.AppendLine($"{indentStr}    Component.{textMeshProComponent.SafeName}.Get().SetText(text);");
        _ = sb.AppendLine($"{indentStr}  }}");
      }

      // Generate type-safe Component accessor class
      if (go.Components.Count > 0)
      {
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static class Component");
        _ = sb.AppendLine($"{indentStr}  {{");

        // Check if there are any custom scripts
        var hasCustomScripts = go.Components.Any(c => c.IsCustomScript);

        // Generate non-custom script components
        foreach (var component in go.Components.Where(c => !c.IsCustomScript))
        {
          _ = sb.AppendLine($"{indentStr}    public static class {component.SafeName}");
          _ = sb.AppendLine($"{indentStr}    {{");
          _ = sb.AppendLine($"{indentStr}      public static {component.TypeFullName} Get()");
          _ = sb.AppendLine($"{indentStr}      {{");
          _ = sb.AppendLine($"{indentStr}        var go = {className}.Get();");
          _ = sb.AppendLine($"{indentStr}        var component = go.GetComponent<{component.TypeFullName}>();");
          _ = sb.AppendLine($"{indentStr}        if (component == null)");
          _ = sb.AppendLine($"{indentStr}        {{");
          _ = sb.AppendLine($"{indentStr}          throw new System.Exception($\"[AssetAccessor.GameObject] Component {component.TypeFullName} not found on GameObject '{go.Name}'\");");
          _ = sb.AppendLine($"{indentStr}        }}");
          _ = sb.AppendLine($"{indentStr}        return component;");
          _ = sb.AppendLine($"{indentStr}      }}");
          _ = sb.AppendLine($"{indentStr}    }}");
        }

        // Generate Script accessor class for custom scripts
        if (hasCustomScripts)
        {
          _ = sb.AppendLine($"{indentStr}    public static class Script");
          _ = sb.AppendLine($"{indentStr}    {{");

          foreach (var component in go.Components.Where(c => c.IsCustomScript))
          {
            var scriptAlias = GetScriptAlias(component.TypeFullName);
            _ = sb.AppendLine($"{indentStr}      public static {scriptAlias} Get{component.SafeName}()");
            _ = sb.AppendLine($"{indentStr}      {{");
            _ = sb.AppendLine($"{indentStr}        var go = {className}.Get();");
            _ = sb.AppendLine($"{indentStr}        var component = go.GetComponent<{scriptAlias}>();");
            _ = sb.AppendLine($"{indentStr}        if (component == null)");
            _ = sb.AppendLine($"{indentStr}        {{");
            _ = sb.AppendLine($"{indentStr}          throw new System.Exception($\"[AssetAccessor.GameObject] Component {component.TypeFullName} not found on GameObject '{go.Name}'\");");
            _ = sb.AppendLine($"{indentStr}        }}");
            _ = sb.AppendLine($"{indentStr}        return component;");
            _ = sb.AppendLine($"{indentStr}      }}");
          }

          _ = sb.AppendLine($"{indentStr}    }}");
        }

        _ = sb.AppendLine($"{indentStr}  }}");
      }

      // Generate child GameObjects as nested classes
      var children = allGameObjects.Where(child => child.ParentId == go.Id).ToList();
      if (children.Count > 0)
      {
        _ = sb.AppendLine();

        // Reserve parent class name to prevent child classes from having the same name
        var childUsedNames = new HashSet<string> { className };

        foreach (var child in children)
        {
          GenerateGameObjectClass(sb, child, allGameObjects, indent + 2, childUsedNames);
        }
      }

      _ = sb.AppendLine($"{indentStr}}}");
    }

    private static List<GameObjectInfo> ParseSceneGameObjects(string scenePath)
    {
      var gameObjects = new List<GameObjectInfo>();

      if (!File.Exists(scenePath))
      {
        return gameObjects;
      }

      var content = File.ReadAllText(scenePath);

      // Parse PrefabInstances to extract GameObject names, parent transforms, and GUIDs
      var prefabInstancePattern = new Regex(
        @"--- !u!1001 &(\d+)\s+PrefabInstance:.*?m_TransformParent: \{fileID: (\d+)\}.*?propertyPath: m_Name\s+value: (.+?)\s+.*?guid: ([0-9a-f]+),",
        RegexOptions.Singleline
      );
      var prefabMatches = prefabInstancePattern.Matches(content);
      var prefabInstances = new Dictionary<string, (string parentTransformId, string name, string guid)>();

      foreach (Match match in prefabMatches)
      {
        var prefabId = match.Groups[1].Value;
        var parentTransformId = match.Groups[2].Value;
        var name = match.Groups[3].Value.Trim();
        var guid = match.Groups[4].Value.Trim();
        prefabInstances[prefabId] = (parentTransformId, name, guid);
      }      // Parse stripped transforms from PrefabInstances
      // Pattern: --- !u!224 &<transformId> stripped\nRectTransform:...\n  m_PrefabInstance: {fileID: <prefabId>}
      var strippedTransformPattern = new Regex(
        @"--- !u!(?:224|4) &(\d+) stripped\s+(?:RectTransform|Transform):.*?m_PrefabInstance: \{fileID: (\d+)\}",
        RegexOptions.Singleline
      );
      var strippedMatches = strippedTransformPattern.Matches(content);
      var prefabTransformToPrefabId = new Dictionary<string, string>();

      foreach (Match match in strippedMatches)
      {
        var transformId = match.Groups[1].Value;
        var prefabId = match.Groups[2].Value;
        if (prefabInstances.ContainsKey(prefabId))
        {
          prefabTransformToPrefabId[transformId] = prefabId;
        }
      }

      // Parse stripped GameObjects from PrefabInstances
      // Pattern: --- !u!1 &<gameObjectId> stripped\nGameObject:...\n  m_PrefabInstance: {fileID: <prefabId>}
      var strippedGameObjectPattern = new Regex(
        @"--- !u!1 &(\d+) stripped\s+GameObject:.*?m_PrefabInstance: \{fileID: (\d+)\}",
        RegexOptions.Singleline
      );
      var strippedGameObjectMatches = strippedGameObjectPattern.Matches(content);
      var strippedGameObjectToPrefabId = new Dictionary<string, string>();

      foreach (Match match in strippedGameObjectMatches)
      {
        var gameObjectId = match.Groups[1].Value;
        var prefabId = match.Groups[2].Value;
        if (prefabInstances.ContainsKey(prefabId))
        {
          strippedGameObjectToPrefabId[gameObjectId] = prefabId;
        }
      }

      // Parse GameObjects from YAML
      // Pattern: --- !u!1 &<id>\nGameObject:\n...\n  m_Name: <name>
      var gameObjectPattern = new Regex(@"--- !u!1 &(\d+)\s+GameObject:.*?m_Name:\s*(.+?)$", RegexOptions.Singleline | RegexOptions.Multiline);
      var matches = gameObjectPattern.Matches(content);

      foreach (Match match in matches)
      {
        var id = match.Groups[1].Value;
        var name = match.Groups[2].Value.Trim();

        if (string.IsNullOrEmpty(name))
        {
          continue; // Skip empty names
        }

        gameObjects.Add(new GameObjectInfo
        {
          Id = id,
          Name = name,
          ParentId = null,
          IsPrefabInstance = false,
          PrefabGuid = null
        });
      }

      // Add PrefabInstance GameObjects with virtual IDs
      foreach (var kvp in prefabInstances)
      {
        var prefabId = kvp.Key;
        var (parentTransformId, name, guid) = kvp.Value;

        gameObjects.Add(new GameObjectInfo
        {
          Id = $"prefab_{prefabId}",
          Name = name,
          ParentId = null, // Will be resolved later
          IsPrefabInstance = true,
          PrefabGuid = guid,
          PrefabParentTransformId = parentTransformId
        });
      }

      // Build mapping: Transform/RectTransform ID -> GameObject ID
      var transformToGameObject = new Dictionary<string, string>();

      // Pattern matches Transform or RectTransform blocks
      // Match from block start to next block or end of file
      var transformBlockPattern = new Regex(@"--- !u!(?:224|4) &(\d+)\s+(?:RectTransform|Transform):.*?(?=^--- |\z)", RegexOptions.Singleline | RegexOptions.Multiline);
      var transformMatches = transformBlockPattern.Matches(content);

      // Convert to array for multiple iterations
      var transformBlocks = transformMatches.Cast<Match>().ToArray();

      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (gameObjectMatch.Success)
        {
          var gameObjectId = gameObjectMatch.Groups[1].Value;
          transformToGameObject[transformId] = gameObjectId;
        }
      }

      // Parse parent-child relationships
      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (!gameObjectMatch.Success) continue;
        var gameObjectId = gameObjectMatch.Groups[1].Value;

        // Extract m_Father from this block
        var fatherMatch = Regex.Match(blockContent, @"m_Father:\s*\{fileID:\s*(\d+)\}");
        if (!fatherMatch.Success) continue;
        var parentTransformId = fatherMatch.Groups[1].Value;

        // parentId "0" means no parent (root GameObject)
        if (parentTransformId != "0" && transformToGameObject.TryGetValue(parentTransformId, out var parentGameObjectId))
        {
          var go = gameObjects.FirstOrDefault(g => g.Id == gameObjectId);
          if (go != null)
          {
            go.ParentId = parentGameObjectId;
          }
        }
      }

      // Resolve PrefabInstance parent relationships
      foreach (var go in gameObjects.Where(g => g.IsPrefabInstance))
      {
        var parentTransformId = go.PrefabParentTransformId;
        if (!string.IsNullOrEmpty(parentTransformId) && parentTransformId != "0")
        {
          if (transformToGameObject.TryGetValue(parentTransformId, out var parentGameObjectId))
          {
            go.ParentId = parentGameObjectId;
          }
        }
      }

      // Parse components for each GameObject
      ParseComponentsForGameObjects(content, gameObjects, strippedGameObjectToPrefabId);

      // Load components from prefab files for PrefabInstances
      LoadPrefabComponents(gameObjects, Path.GetDirectoryName(scenePath));

      return gameObjects;
    }

    private static void ParseComponentsForGameObjects(string content, List<GameObjectInfo> gameObjects, Dictionary<string, string> strippedGameObjectToPrefabId)
    {
      // Create a dictionary for quick lookup
      var gameObjectDict = gameObjects.ToDictionary(go => go.Id);

      // Parse MonoBehaviour components (UI components like Image, Button, Text, etc.)
      // Match both regular and stripped MonoBehaviour components
      var monoBehaviourPattern = new Regex(
        @"--- !u!114 &-?\d+(?:\s+stripped)?\s+MonoBehaviour:.*?m_GameObject:\s*\{fileID:\s*(-?\d+)\}.*?m_EditorClassIdentifier:\s*(.+?)$",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var monoBehaviourMatches = monoBehaviourPattern.Matches(content);

      foreach (Match match in monoBehaviourMatches)
      {
        var gameObjectId = match.Groups[1].Value;
        var editorClassIdentifier = match.Groups[2].Value.Trim();

        // Try to find the GameObject directly, or map from stripped GameObject ID to PrefabInstance virtual ID
        if (!gameObjectDict.TryGetValue(gameObjectId, out GameObjectInfo go))
        {
          // This might be a stripped GameObject from a PrefabInstance, try to map it to the virtual GameObject ID
          if (strippedGameObjectToPrefabId.TryGetValue(gameObjectId, out var prefabId))
          {
            var virtualId = $"prefab_{prefabId}";
            _ = gameObjectDict.TryGetValue(virtualId, out go);
          }
        }

        if (go != null && !string.IsNullOrEmpty(editorClassIdentifier))
        {
          var componentType = ParseComponentType(editorClassIdentifier);
          if (!string.IsNullOrEmpty(componentType))
          {
            var safeName = MakeSafeName(componentType.Split('.').Last());
            var isCustomScript = !IsUnityOrKnownComponent(componentType);
            var componentInfo = new ComponentInfo
            {
              TypeFullName = componentType,
              SafeName = safeName,
              IsCustomScript = isCustomScript
            };

            // Parse custom script members if it's a custom script
            if (isCustomScript)
            {
              ParseCustomScriptMembers(componentInfo);

              // Skip custom scripts with no public members (no accessor needed)
              if (componentInfo.CustomScriptMembers.Count == 0)
              {
                continue;
              }
            }

            go.Components.Add(componentInfo);
          }
        }
      }

      // Parse other common component types
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!223", "UnityEngine.Canvas", "Canvas");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!222", "UnityEngine.CanvasRenderer", "CanvasRenderer");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!224", "UnityEngine.RectTransform", "RectTransform");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!4", "UnityEngine.Transform", "Transform");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!20", "UnityEngine.Camera", "Camera");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!81", "UnityEngine.AudioListener", "AudioListener");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!108", "UnityEngine.Light", "Light");
      ParseStandardComponents(content, gameObjectDict, strippedGameObjectToPrefabId, "!u!114", "UnityEngine.EventSystems.EventSystem", "EventSystem");
    }

    private static void ParseStandardComponents(string content, Dictionary<string, GameObjectInfo> gameObjectDict, Dictionary<string, string> strippedGameObjectToPrefabId, string classId, string componentType, string componentName)
    {
      var pattern = new Regex(
        $@"--- {Regex.Escape(classId)} &\d+\s+{Regex.Escape(componentName)}:.*?m_GameObject:\s*\{{fileID:\s*(\d+)\}}",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var matches = pattern.Matches(content);

      foreach (Match match in matches)
      {
        var gameObjectId = match.Groups[1].Value;

        // Try to find the GameObject directly, or map from stripped GameObject ID to PrefabInstance virtual ID
        if (!gameObjectDict.TryGetValue(gameObjectId, out GameObjectInfo go))
        {
          // This might be a stripped GameObject from a PrefabInstance, try to map it to the virtual GameObject ID
          if (strippedGameObjectToPrefabId.TryGetValue(gameObjectId, out var prefabId))
          {
            var virtualId = $"prefab_{prefabId}";
            _ = gameObjectDict.TryGetValue(virtualId, out go);
          }
        }

        if (go != null)
        {
          var safeName = MakeSafeName(componentType.Split('.').Last());
          // Avoid duplicates
          if (!go.Components.Any(c => c.TypeFullName == componentType))
          {
            go.Components.Add(new ComponentInfo
            {
              TypeFullName = componentType,
              SafeName = safeName
            });
          }
        }
      }
    }

    private static string ParseComponentType(string editorClassIdentifier)
    {
      // editorClassIdentifier format examples:
      // "UnityEngine.UI::UnityEngine.UI.Image"
      // "UnityEngine.EventSystems::UnityEngine.EventSystems.EventSystem"
      // "::CustomScript"

      if (string.IsNullOrEmpty(editorClassIdentifier))
      {
        return null;
      }

      var parts = editorClassIdentifier.Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);
      if (parts.Length == 2)
      {
        return parts[1].Trim();
      }
      else if (parts.Length == 1)
      {
        return parts[0].Trim();
      }

      return null;
    }

    private static bool IsUnityOrKnownComponent(string componentType)
    {
      if (string.IsNullOrEmpty(componentType))
      {
        return false;
      }

      // Include only Unity engine components and known third-party packages
      // Exclude custom user scripts
      return componentType.StartsWith("UnityEngine.") ||
            componentType.StartsWith("UnityEditor.") ||
            componentType.StartsWith("Unity.") ||
            componentType.StartsWith("TMPro.") || // TextMeshPro
            componentType.StartsWith("Cinemachine.") || // Cinemachine
            componentType.StartsWith("UnityEngine.InputSystem."); // Input System
    }

    private static List<string> GenerateCustomScriptAliases(List<GameObjectInfo> gameObjects)
    {
      var aliases = new List<string>();
      var customScripts = new HashSet<string>();
      var scriptCounts = new Dictionary<string, int>();

      // Collect all custom scripts and count occurrences
      foreach (var go in gameObjects)
      {
        foreach (var component in go.Components.Where(c => c.IsCustomScript))
        {
          if (!scriptCounts.ContainsKey(component.TypeFullName))
          {
            scriptCounts[component.TypeFullName] = 0;
          }

          scriptCounts[component.TypeFullName]++;
        }
      }

      // Generate aliases for scripts that appear multiple times or have conflicting names
      foreach (var kvp in scriptCounts)
      {
        var scriptName = kvp.Key;
        var count = kvp.Value;

        if (count > 1)
        {
          // Multiple instances: use _<originalClassName> suffix
          aliases.Add($"using PrefabScript{scriptName}_{scriptName} = {scriptName};");
        }
        else
        {
          // Single instance: use simple alias
          aliases.Add($"using PrefabScript{scriptName} = {scriptName};");
        }
      }

      return aliases;
    }

    private static string GetScriptAlias(string scriptTypeName)
    {
      // Return the alias name for a script type
      return $"PrefabScript{scriptTypeName}";
    }

    private static string ResolveTypeName(string typeName, string scriptContent, string className)
    {
      // Check if the type is defined within the same class (nested type)
      // Look for enum, class, struct, or interface definitions
      var nestedTypePattern = new Regex(
        $@"^\s*public\s+(?:enum|class|struct|interface)\s+{Regex.Escape(typeName)}\s*(?:\{{|:)",
        RegexOptions.Multiline
      );

      if (nestedTypePattern.IsMatch(scriptContent))
      {
        // It's a nested type, prepend the class name with alias
        return $"{GetScriptAlias(className)}.{typeName}";
      }

      // Otherwise, return the type as-is (it's either a built-in type or from another namespace)
      return typeName;
    }

    private static void ParseCustomScriptMembers(ComponentInfo componentInfo)
    {
      // Find the script file in the Assets folder
      var scriptName = componentInfo.TypeFullName.Split('.').Last();
      var scriptPaths = Directory.GetFiles("Assets", $"{scriptName}.cs", SearchOption.AllDirectories);

      if (scriptPaths.Length == 0)
      {
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Script file not found for: {scriptName}");
        return;
      }

      var scriptPath = scriptPaths[0];
      var scriptContent = File.ReadAllText(scriptPath);

      // Parse public properties
      var propertyPattern = new Regex(
        @"^\s*public\s+(?:(?:virtual|override|abstract)\s+)?([\w<>\[\],\(\)\s]+)\s+(\w+)\s*\{([^}]*)\}",
        RegexOptions.Multiline
      );
      var propertyMatches = propertyPattern.Matches(scriptContent);
      foreach (Match match in propertyMatches)
      {
        var returnType = match.Groups[1].Value.Trim();
        var memberName = match.Groups[2].Value.Trim();
        var propertyBody = match.Groups[3].Value.Trim();

        // Check if property has a getter
        if (!propertyBody.Contains("get")) continue;

        // Check if property has a public/internal setter (not private or protected)
        var hasSetter = propertyBody.Contains("set") &&
                      !Regex.IsMatch(propertyBody, @"\b(private|protected)\s+set\b");

        // Skip if it's from a base class or if it's a private/protected setter property
        if (!string.IsNullOrEmpty(memberName))
        {
          // Resolve type name for nested types
          var resolvedType = ResolveTypeName(returnType, scriptContent, scriptName);

          componentInfo.CustomScriptMembers.Add(new ScriptMemberInfo
          {
            Name = memberName,
            ReturnType = resolvedType,
            Type = MemberType.Property,
            HasSetter = hasSetter
          });
        }
      }

      // Parse public readonly fields
      var readonlyFieldPattern = new Regex(
        @"^\s*public\s+(?:readonly\s+)([\w.<>\[\]]+)\s+(\w+)\s*(?:=|;)",
        RegexOptions.Multiline
      );
      var readonlyFieldMatches = readonlyFieldPattern.Matches(scriptContent);
      foreach (Match match in readonlyFieldMatches)
      {
        var fieldType = match.Groups[1].Value.Trim();
        var fieldName = match.Groups[2].Value.Trim();

        if (!string.IsNullOrEmpty(fieldName))
        {
          // Resolve type name for nested types
          var resolvedType = ResolveTypeName(fieldType, scriptContent, scriptName);

          componentInfo.CustomScriptMembers.Add(new ScriptMemberInfo
          {
            Name = fieldName,
            ReturnType = resolvedType,
            Type = MemberType.Field,
            HasSetter = false
          });
        }
      }

      // Parse public methods (excluding Unity lifecycle methods)
      var methodPattern = new Regex(
        @"^\s*public\s+(?:(?:virtual|override|abstract|async)\s+)?([\w<>\[\]]+)\s+(\w+)\s*\(([^)]*)\)",
        RegexOptions.Multiline
      );
      var methodMatches = methodPattern.Matches(scriptContent);
      var unityLifecycleMethods = new HashSet<string> {
        "Awake", "Start", "Update", "FixedUpdate", "LateUpdate",
        "OnEnable", "OnDisable", "OnDestroy", "OnValidate", "Reset",
        "OnApplicationQuit", "OnApplicationPause", "OnApplicationFocus"
      };

      foreach (Match match in methodMatches)
      {
        var returnType = match.Groups[1].Value.Trim();
        var memberName = match.Groups[2].Value.Trim();
        var parametersStr = match.Groups[3].Value.Trim();

        // Skip Unity lifecycle methods
        if (unityLifecycleMethods.Contains(memberName))
        {
          continue;
        }

        var parameters = new List<ParameterInfo>();
        if (!string.IsNullOrEmpty(parametersStr))
        {
          var paramParts = parametersStr.Split(',');
          foreach (var paramPart in paramParts)
          {
            var trimmed = paramPart.Trim();
            if (string.IsNullOrEmpty(trimmed)) continue;

            // Parse parameter (format: "Type name" or "Type name = default")
            var paramMatch = Regex.Match(trimmed, @"([\w<>\[\]]+)\s+(\w+)");
            if (paramMatch.Success)
            {
              var paramType = paramMatch.Groups[1].Value.Trim();
              var paramName = paramMatch.Groups[2].Value.Trim();

              // Resolve parameter type name for nested types
              var resolvedParamType = ResolveTypeName(paramType, scriptContent, scriptName);

              parameters.Add(new ParameterInfo
              {
                Type = resolvedParamType,
                Name = paramName
              });
            }
          }
        }

        if (!string.IsNullOrEmpty(memberName))
        {
          // Resolve return type name for nested types
          var resolvedReturnType = ResolveTypeName(returnType, scriptContent, scriptName);

          componentInfo.CustomScriptMembers.Add(new ScriptMemberInfo
          {
            Name = memberName,
            ReturnType = resolvedReturnType,
            Type = MemberType.Method,
            Parameters = parameters
          });
        }
      }
    }

    private static void LoadPrefabComponents(List<GameObjectInfo> gameObjects, string sceneDir)
    {
      // Get the Assets directory path
      var assetsPath = Path.GetFullPath(Path.Combine(sceneDir, "..", ".."));

      // Create a list of prefab children to add after iteration
      var prefabChildrenToAdd = new List<GameObjectInfo>();

      foreach (var go in gameObjects.Where(g => g.IsPrefabInstance && !string.IsNullOrEmpty(g.PrefabGuid)).ToList())
      {
        // Find prefab file by GUID
        var prefabPath = FindAssetPathByGuid(go.PrefabGuid, assetsPath);
        if (string.IsNullOrEmpty(prefabPath) || !File.Exists(prefabPath))
        {
          continue;
        }

        // Parse prefab file to extract all GameObjects and build hierarchy
        var prefabContent = File.ReadAllText(prefabPath);
        var prefabGameObjects = ParsePrefabGameObjects(prefabContent);

        // Find the root GameObject in the prefab
        var rootPrefabGO = prefabGameObjects.FirstOrDefault(pgo => string.IsNullOrEmpty(pgo.ParentId));
        if (rootPrefabGO != null)
        {
          // Add root GameObject's components to the PrefabInstance
          foreach (var component in rootPrefabGO.Components)
          {
            if (!go.Components.Any(c => c.TypeFullName == component.TypeFullName))
            {
              go.Components.Add(component);
            }
          }

          // Create mapping of prefab GameObject IDs to their GameObjectInfo
          var prefabIdMap = prefabGameObjects.ToDictionary(pgo => pgo.Id);

          // Add child GameObjects from prefab to the list for later addition
          foreach (var childGO in prefabGameObjects.Where(pgo => !string.IsNullOrEmpty(pgo.ParentId)))
          {
            // Create a new GameObject with prefab-based virtual ID
            var prefabChildId = $"{go.Id}_child_{childGO.Id}";

            // Determine the correct parent ID in the scene's GameObject list
            string sceneParentId;
            if (childGO.ParentId == rootPrefabGO.Id)
            {
              // Direct child of root prefab GameObject -> parent is the PrefabInstance itself
              sceneParentId = go.Id;
            }
            else
            {
              // Nested child -> parent is also a prefab child
              sceneParentId = $"{go.Id}_child_{childGO.ParentId}";
            }

            prefabChildrenToAdd.Add(new GameObjectInfo
            {
              Id = prefabChildId,
              Name = childGO.Name,
              ParentId = sceneParentId,
              Components = new List<ComponentInfo>(childGO.Components),
              IsPrefabInstance = false,
              IsPrefabChild = true
            });
          }
        }
      }

      // Add all prefab children after iteration
      gameObjects.AddRange(prefabChildrenToAdd);
    }

    private static string FindAssetPathByGuid(string guid, string assetsPath)
    {
      // Search for .meta files containing the GUID
      var metaFiles = Directory.GetFiles(assetsPath, "*.meta", SearchOption.AllDirectories);

      foreach (var metaFile in metaFiles)
      {
        var metaContent = File.ReadAllText(metaFile);
        if (metaContent.Contains($"guid: {guid}"))
        {
          // Return the actual file path (remove .meta extension)
          var assetPath = metaFile[..^5];
          if (File.Exists(assetPath))
          {
            return assetPath;
          }
        }
      }

      return null;
    }

    private static List<GameObjectInfo> ParsePrefabGameObjects(string prefabContent)
    {
      var gameObjects = new List<GameObjectInfo>();

      // Parse all GameObjects in the prefab
      var gameObjectPattern = new Regex(@"--- !u!1 &(\d+)\s+GameObject:.*?m_Name:\s*(.+?)$", RegexOptions.Singleline | RegexOptions.Multiline);
      var matches = gameObjectPattern.Matches(prefabContent);

      foreach (Match match in matches)
      {
        var id = match.Groups[1].Value;
        var name = match.Groups[2].Value.Trim();

        if (string.IsNullOrEmpty(name))
        {
          continue;
        }

        gameObjects.Add(new GameObjectInfo
        {
          Id = id,
          Name = name,
          ParentId = null,
          IsPrefabInstance = false
        });
      }

      // Build mapping: Transform/RectTransform ID -> GameObject ID
      var transformToGameObject = new Dictionary<string, string>();
      var transformBlockPattern = new Regex(@"--- !u!(?:224|4) &(\d+)\s+(?:RectTransform|Transform):.*?(?=^--- |\z)", RegexOptions.Singleline | RegexOptions.Multiline);
      var transformMatches = transformBlockPattern.Matches(prefabContent);
      var transformBlocks = transformMatches.Cast<Match>().ToArray();

      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (gameObjectMatch.Success)
        {
          var gameObjectId = gameObjectMatch.Groups[1].Value;
          transformToGameObject[transformId] = gameObjectId;
        }
      }

      // Parse parent-child relationships
      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (!gameObjectMatch.Success) continue;
        var gameObjectId = gameObjectMatch.Groups[1].Value;

        var fatherMatch = Regex.Match(blockContent, @"m_Father:\s*\{fileID:\s*(\d+)\}");
        if (!fatherMatch.Success) continue;
        var parentTransformId = fatherMatch.Groups[1].Value;

        if (parentTransformId != "0" && transformToGameObject.TryGetValue(parentTransformId, out var parentGameObjectId))
        {
          var go = gameObjects.FirstOrDefault(g => g.Id == gameObjectId);
          if (go != null)
          {
            go.ParentId = parentGameObjectId;
          }
        }
      }

      // Parse components for each GameObject
      foreach (var go in gameObjects)
      {
        var addedTypes = new HashSet<string>();

        // Parse MonoBehaviour components
        var monoBehaviourPattern = new Regex(
          @"--- !u!114 &-?\d+(?:\s+stripped)?\s+MonoBehaviour:.*?m_GameObject:\s*\{fileID:\s*(-?\d+)\}.*?m_EditorClassIdentifier:\s*(.+?)$",
          RegexOptions.Singleline | RegexOptions.Multiline
        );
        var monoBehaviourMatches = monoBehaviourPattern.Matches(prefabContent);

        foreach (Match match in monoBehaviourMatches)
        {
          var gameObjectId = match.Groups[1].Value;
          if (gameObjectId != go.Id) continue;

          var editorClassIdentifier = match.Groups[2].Value.Trim();
          var componentType = ParseComponentType(editorClassIdentifier);

          if (!string.IsNullOrEmpty(componentType) && !addedTypes.Contains(componentType))
          {
            var safeName = MakeSafeName(componentType.Split('.').Last());
            var isCustomScript = !IsUnityOrKnownComponent(componentType);
            var componentInfo = new ComponentInfo
            {
              TypeFullName = componentType,
              SafeName = safeName,
              IsCustomScript = isCustomScript
            };

            // Parse custom script members if it's a custom script
            if (isCustomScript)
            {
              ParseCustomScriptMembers(componentInfo);

              // Skip custom scripts with no public members (no accessor needed)
              if (componentInfo.CustomScriptMembers.Count == 0)
              {
                continue;
              }
            }

            go.Components.Add(componentInfo);
            _ = addedTypes.Add(componentType);
          }
        }

        // Parse standard components
        ParsePrefabStandardComponent(prefabContent, go.Id, "!u!223", "UnityEngine.Canvas", go.Components, addedTypes);
        ParsePrefabStandardComponent(prefabContent, go.Id, "!u!222", "UnityEngine.CanvasRenderer", go.Components, addedTypes);
        ParsePrefabStandardComponent(prefabContent, go.Id, "!u!224", "UnityEngine.RectTransform", go.Components, addedTypes);
        ParsePrefabStandardComponent(prefabContent, go.Id, "!u!4", "UnityEngine.Transform", go.Components, addedTypes);
        ParsePrefabStandardComponent(prefabContent, go.Id, "!u!20", "UnityEngine.Camera", go.Components, addedTypes);
        ParsePrefabStandardComponent(prefabContent, go.Id, "!u!81", "UnityEngine.AudioListener", go.Components, addedTypes);
        ParsePrefabStandardComponent(prefabContent, go.Id, "!u!108", "UnityEngine.Light", go.Components, addedTypes);
      }

      return gameObjects;
    }

    private static void ParsePrefabStandardComponent(string content, string gameObjectId, string classId, string componentType, List<ComponentInfo> components, HashSet<string> addedTypes)
    {
      var componentName = componentType.Split('.').Last();
      var pattern = new Regex(
        $@"--- {Regex.Escape(classId)} &\d+\s+{Regex.Escape(componentName)}:.*?m_GameObject:\s*\{{fileID:\s*(\d+)\}}",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var matches = pattern.Matches(content);

      foreach (Match match in matches)
      {
        var goId = match.Groups[1].Value;
        if (goId == gameObjectId && !addedTypes.Contains(componentType))
        {
          var safeName = MakeSafeName(componentName);
          components.Add(new ComponentInfo
          {
            TypeFullName = componentType,
            SafeName = safeName
          });
          _ = addedTypes.Add(componentType);
          break;
        }
      }
    }

    private static string MakeSafeName(string name)
    {
      if (string.IsNullOrEmpty(name)) return "_";

      var sb = new StringBuilder(name.Length);
      bool upperNext = true;

      foreach (var ch in name)
      {
        if (char.IsLetterOrDigit(ch))
        {
          _ = sb.Append(upperNext ? char.ToUpperInvariant(ch) : ch);
          upperNext = false;
        }
        else
        {
          upperNext = true;
        }
      }

      if (sb.Length == 0) _ = sb.Append("_");
      if (char.IsDigit(sb[0])) _ = sb.Insert(0, '_');

      var result = sb.ToString();

      // Avoid reserved/problematic names that would conflict with enclosing types or Unity types
      if (result == "GameObject")
      {
        result = $"{result}_";
      }

      return result;
    }

    private class GameObjectInfo
    {
      public string Id { get; set; }
      public string Name { get; set; }
      public string ParentId { get; set; }
      public List<ComponentInfo> Components { get; set; } = new List<ComponentInfo>();
      public bool IsPrefabInstance { get; set; }
      public string PrefabGuid { get; set; }
      public string PrefabParentTransformId { get; set; }
      public List<GameObjectInfo> Children { get; set; } = new List<GameObjectInfo>();
      public bool IsPrefabChild { get; set; }
    }

    private class ComponentInfo
    {
      public string TypeFullName { get; set; }
      public string SafeName { get; set; }
      public bool IsCustomScript { get; set; }
      public List<ScriptMemberInfo> CustomScriptMembers { get; set; } = new List<ScriptMemberInfo>();
    }

    private class ScriptMemberInfo
    {
      public string Name { get; set; }
      public string ReturnType { get; set; }
      public MemberType Type { get; set; }
      public List<ParameterInfo> Parameters { get; set; } = new List<ParameterInfo>();
      public bool HasSetter { get; set; }
    }

    private class ParameterInfo
    {
      public string Name { get; set; }
      public string Type { get; set; }
    }

    private enum MemberType
    {
      Method,
      Property,
      Field
    }
  }
}
#endif
