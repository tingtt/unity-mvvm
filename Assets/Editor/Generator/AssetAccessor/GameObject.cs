#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;

public static partial class AssetAccessorGenerator
{
  public static class GameObjectAccessor
  {
    public static void Generate(string outputDir)
    {
      if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
      {
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Creating directory: {outputDir}");
        _ = Directory.CreateDirectory(outputDir);
      }

      GenerateGameObjectFiles(outputDir);

      AssetDatabase.Refresh();
    }

    private static void GenerateGameObjectFiles(string outputDir)
    {
      var scenes = EditorBuildSettings.scenes
        .Where(s => s.enabled)
        .ToArray();

      if (scenes.Length == 0)
      {
        Console.WriteLine("[AssetAccessorGenerator.GameObjectAccessor] No scenes in build settings.");
        return;
      }

      foreach (var scene in scenes)
      {
        var sceneName = Path.GetFileNameWithoutExtension(scene.path);
        var sceneEnumName = MakeSafeName(sceneName);
        var gameObjects = ParseSceneGameObjects(scene.path);

        if (gameObjects.Count == 0)
        {
          continue;
        }

        var sb = new StringBuilder();

        _ = sb.AppendLine("// <auto-generated />");
        _ = sb.AppendLine($"// This file is generated by AssetAccessorGenerator.GameObjectAccessor for scene: {sceneName}. Do not edit manually.");
        _ = sb.AppendLine("using UnityEngine;");
        _ = sb.AppendLine();
        _ = sb.AppendLine("public static partial class AssetAccessor");
        _ = sb.AppendLine("{");
        _ = sb.AppendLine("  public static partial class Scene");
        _ = sb.AppendLine("  {");
        _ = sb.AppendLine($"    public static partial class {sceneEnumName}");
        _ = sb.AppendLine("    {");
        _ = sb.AppendLine("      public static partial class GameObject");
        _ = sb.AppendLine("      {");

        // Generate root GameObjects
        var rootGameObjects = gameObjects.Where(go => string.IsNullOrEmpty(go.ParentId)).ToList();
        var usedNames = new HashSet<string>();
        foreach (var go in rootGameObjects)
        {
          GenerateGameObjectClass(sb, go, gameObjects, 8, usedNames);
        }

        _ = sb.AppendLine("      }");
        _ = sb.AppendLine("    }");
        _ = sb.AppendLine("  }");
        _ = sb.AppendLine("}");

        var outputPath = Path.Combine(outputDir, $"{sceneEnumName}.cs");
        File.WriteAllText(outputPath, sb.ToString(), new UTF8Encoding(false));
        Console.WriteLine($"[AssetAccessorGenerator.GameObjectAccessor] Generated: {outputPath}");
      }
    }

    private static void GenerateGameObjectClass(StringBuilder sb, GameObjectInfo go, List<GameObjectInfo> allGameObjects, int indent, HashSet<string> usedNames)
    {
      var indentStr = new string(' ', indent);
      var baseName = MakeSafeName(go.Name);
      var className = baseName;

      // Handle duplicate names by appending numbers
      var counter = 1;
      while (usedNames.Contains(className))
      {
        className = $"{baseName}{counter}";
        counter++;
      }

      _ = usedNames.Add(className);

      _ = sb.AppendLine($"{indentStr}public static class {className}");
      _ = sb.AppendLine($"{indentStr}{{");

      // Generate GetGameObject method
      _ = sb.AppendLine($"{indentStr}  public static UnityEngine.GameObject Get()");
      _ = sb.AppendLine($"{indentStr}  {{");
      _ = sb.AppendLine($"{indentStr}    return Scene.GameObjectCacheController.GetGameObject(\"{go.Name}\")");
      _ = sb.AppendLine($"{indentStr}      ?? throw new System.Exception($\"[AssetAccessor.GameObject] GameObject '{go.Name}' not found or scene not loaded\");");
      _ = sb.AppendLine($"{indentStr}  }}");

      // Generate type-safe Component accessor class
      if (go.Components.Count > 0)
      {
        _ = sb.AppendLine();
        _ = sb.AppendLine($"{indentStr}  public static class Component");
        _ = sb.AppendLine($"{indentStr}  {{");

        foreach (var component in go.Components)
        {
          _ = sb.AppendLine($"{indentStr}    public static class {component.SafeName}");
          _ = sb.AppendLine($"{indentStr}    {{");
          _ = sb.AppendLine($"{indentStr}      public static {component.TypeFullName} Get()");
          _ = sb.AppendLine($"{indentStr}      {{");
          _ = sb.AppendLine($"{indentStr}        var go = {className}.Get();");
          _ = sb.AppendLine($"{indentStr}        var component = go.GetComponent<{component.TypeFullName}>();");
          _ = sb.AppendLine($"{indentStr}        if (component == null)");
          _ = sb.AppendLine($"{indentStr}        {{");
          _ = sb.AppendLine($"{indentStr}          throw new System.Exception($\"[AssetAccessor.GameObject] Component {component.TypeFullName} not found on GameObject '{go.Name}'\");");
          _ = sb.AppendLine($"{indentStr}        }}");
          _ = sb.AppendLine($"{indentStr}        return component;");
          _ = sb.AppendLine($"{indentStr}      }}");
          _ = sb.AppendLine($"{indentStr}    }}");
        }

        _ = sb.AppendLine($"{indentStr}  }}");
      }

      // Generate child GameObjects as nested classes
      var children = allGameObjects.Where(child => child.ParentId == go.Id).ToList();
      if (children.Count > 0)
      {
        _ = sb.AppendLine();

        // Reserve parent class name to prevent child classes from having the same name
        var childUsedNames = new HashSet<string> { className };

        foreach (var child in children)
        {
          GenerateGameObjectClass(sb, child, allGameObjects, indent + 2, childUsedNames);
        }
      }

      _ = sb.AppendLine($"{indentStr}}}");
    }

    private static List<GameObjectInfo> ParseSceneGameObjects(string scenePath)
    {
      var gameObjects = new List<GameObjectInfo>();

      if (!File.Exists(scenePath))
      {
        return gameObjects;
      }

      var content = File.ReadAllText(scenePath);

      // Parse GameObjects from YAML
      // Pattern: --- !u!1 &<id>\nGameObject:\n...\n  m_Name: <name>
      var gameObjectPattern = new Regex(@"--- !u!1 &(\d+)\s+GameObject:.*?m_Name:\s*(.+?)$", RegexOptions.Singleline | RegexOptions.Multiline);
      var matches = gameObjectPattern.Matches(content);

      foreach (Match match in matches)
      {
        var id = match.Groups[1].Value;
        var name = match.Groups[2].Value.Trim();

        if (string.IsNullOrEmpty(name))
        {
          continue; // Skip empty names
        }

        gameObjects.Add(new GameObjectInfo
        {
          Id = id,
          Name = name,
          ParentId = null
        });
      }

      // Build mapping: Transform/RectTransform ID -> GameObject ID
      var transformToGameObject = new Dictionary<string, string>();

      // Pattern matches Transform or RectTransform blocks
      // Match from block start to next block or end of file
      var transformBlockPattern = new Regex(@"--- !u!(?:224|4) &(\d+)\s+(?:RectTransform|Transform):.*?(?=^--- |\z)", RegexOptions.Singleline | RegexOptions.Multiline);
      var transformMatches = transformBlockPattern.Matches(content);

      // Convert to array for multiple iterations
      var transformBlocks = transformMatches.Cast<Match>().ToArray();

      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (gameObjectMatch.Success)
        {
          var gameObjectId = gameObjectMatch.Groups[1].Value;
          transformToGameObject[transformId] = gameObjectId;
        }
      }

      // Parse parent-child relationships
      foreach (var block in transformBlocks)
      {
        var transformId = block.Groups[1].Value;
        var blockContent = block.Value;

        // Extract m_GameObject from this block
        var gameObjectMatch = Regex.Match(blockContent, @"m_GameObject:\s*\{fileID:\s*(\d+)\}");
        if (!gameObjectMatch.Success) continue;
        var gameObjectId = gameObjectMatch.Groups[1].Value;

        // Extract m_Father from this block
        var fatherMatch = Regex.Match(blockContent, @"m_Father:\s*\{fileID:\s*(\d+)\}");
        if (!fatherMatch.Success) continue;
        var parentTransformId = fatherMatch.Groups[1].Value;

        // parentId "0" means no parent (root GameObject)
        if (parentTransformId != "0" && transformToGameObject.TryGetValue(parentTransformId, out var parentGameObjectId))
        {
          var go = gameObjects.FirstOrDefault(g => g.Id == gameObjectId);
          if (go != null)
          {
            go.ParentId = parentGameObjectId;
          }
        }
      }

      // Parse components for each GameObject
      ParseComponentsForGameObjects(content, gameObjects);

      return gameObjects;
    }

    private static void ParseComponentsForGameObjects(string content, List<GameObjectInfo> gameObjects)
    {
      // Create a dictionary for quick lookup
      var gameObjectDict = gameObjects.ToDictionary(go => go.Id);

      // Parse MonoBehaviour components (UI components like Image, Button, Text, etc.)
      var monoBehaviourPattern = new Regex(
        @"--- !u!114 &\d+\s+MonoBehaviour:.*?m_GameObject:\s*\{fileID:\s*(\d+)\}.*?m_EditorClassIdentifier:\s*(.+?)$",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var monoBehaviourMatches = monoBehaviourPattern.Matches(content);

      foreach (Match match in monoBehaviourMatches)
      {
        var gameObjectId = match.Groups[1].Value;
        var editorClassIdentifier = match.Groups[2].Value.Trim();

        if (gameObjectDict.TryGetValue(gameObjectId, out var go) && !string.IsNullOrEmpty(editorClassIdentifier))
        {
          var componentType = ParseComponentType(editorClassIdentifier);
          if (!string.IsNullOrEmpty(componentType) && IsUnityOrKnownComponent(componentType))
          {
            var safeName = MakeSafeName(componentType.Split('.').Last());
            go.Components.Add(new ComponentInfo
            {
              TypeFullName = componentType,
              SafeName = safeName
            });
          }
        }
      }

      // Parse other common component types
      ParseStandardComponents(content, gameObjectDict, "!u!223", "UnityEngine.Canvas", "Canvas");
      ParseStandardComponents(content, gameObjectDict, "!u!222", "UnityEngine.CanvasRenderer", "CanvasRenderer");
      ParseStandardComponents(content, gameObjectDict, "!u!224", "UnityEngine.RectTransform", "RectTransform");
      ParseStandardComponents(content, gameObjectDict, "!u!4", "UnityEngine.Transform", "Transform");
      ParseStandardComponents(content, gameObjectDict, "!u!20", "UnityEngine.Camera", "Camera");
      ParseStandardComponents(content, gameObjectDict, "!u!81", "UnityEngine.AudioListener", "AudioListener");
      ParseStandardComponents(content, gameObjectDict, "!u!108", "UnityEngine.Light", "Light");
      ParseStandardComponents(content, gameObjectDict, "!u!114", "UnityEngine.EventSystems.EventSystem", "EventSystem");
    }

    private static void ParseStandardComponents(string content, Dictionary<string, GameObjectInfo> gameObjectDict, string classId, string componentType, string componentName)
    {
      var pattern = new Regex(
        $@"--- {Regex.Escape(classId)} &\d+\s+{Regex.Escape(componentName)}:.*?m_GameObject:\s*\{{fileID:\s*(\d+)\}}",
        RegexOptions.Singleline | RegexOptions.Multiline
      );
      var matches = pattern.Matches(content);

      foreach (Match match in matches)
      {
        var gameObjectId = match.Groups[1].Value;
        if (gameObjectDict.TryGetValue(gameObjectId, out var go))
        {
          var safeName = MakeSafeName(componentType.Split('.').Last());
          // Avoid duplicates
          if (!go.Components.Any(c => c.TypeFullName == componentType))
          {
            go.Components.Add(new ComponentInfo
            {
              TypeFullName = componentType,
              SafeName = safeName
            });
          }
        }
      }
    }

    private static string ParseComponentType(string editorClassIdentifier)
    {
      // editorClassIdentifier format examples:
      // "UnityEngine.UI::UnityEngine.UI.Image"
      // "UnityEngine.EventSystems::UnityEngine.EventSystems.EventSystem"
      // "::CustomScript"

      if (string.IsNullOrEmpty(editorClassIdentifier))
      {
        return null;
      }

      var parts = editorClassIdentifier.Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);
      if (parts.Length == 2)
      {
        return parts[1].Trim();
      }
      else if (parts.Length == 1)
      {
        return parts[0].Trim();
      }

      return null;
    }

    private static bool IsUnityOrKnownComponent(string componentType)
    {
      if (string.IsNullOrEmpty(componentType))
      {
        return false;
      }

      // Include only Unity engine components and known third-party packages
      // Exclude custom user scripts
      return componentType.StartsWith("UnityEngine.") ||
            componentType.StartsWith("UnityEditor.") ||
            componentType.StartsWith("Unity.") ||
            componentType.StartsWith("TMPro.") || // TextMeshPro
            componentType.StartsWith("Cinemachine.") || // Cinemachine
            componentType.StartsWith("UnityEngine.InputSystem."); // Input System
    }

    private static string MakeSafeName(string name)
    {
      if (string.IsNullOrEmpty(name)) return "_";

      var sb = new StringBuilder(name.Length);
      bool upperNext = true;

      foreach (var ch in name)
      {
        if (char.IsLetterOrDigit(ch))
        {
          _ = sb.Append(upperNext ? char.ToUpperInvariant(ch) : ch);
          upperNext = false;
        }
        else
        {
          upperNext = true;
        }
      }

      if (sb.Length == 0) _ = sb.Append("_");
      if (char.IsDigit(sb[0])) _ = sb.Insert(0, '_');

      var result = sb.ToString();

      // Avoid reserved/problematic names that would conflict with enclosing types or Unity types
      if (result == "GameObject")
      {
        result = $"{result}_";
      }

      return result;
    }

    private class GameObjectInfo
    {
      public string Id { get; set; }
      public string Name { get; set; }
      public string ParentId { get; set; }
      public List<ComponentInfo> Components { get; set; } = new List<ComponentInfo>();
    }

    private class ComponentInfo
    {
      public string TypeFullName { get; set; }
      public string SafeName { get; set; }
    }
  }
}
#endif
